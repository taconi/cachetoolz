{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cache Toolz","text":"<p>This library offers a decorator that enhances the functionality of caching functions.</p> <p>Caching is a technique commonly used in software development to improve performance by storing the results of expensive or time-consuming function calls. With this library, you can easily apply caching to your functions using a decorator.</p> <p>The decorator provided by this library automatically checks if the function has been called with the same set of arguments before. If it has, instead of executing the function again, it returns the cached result, saving valuable processing time. However, if the function is called with new or different arguments, it will execute normally and cache the result for future use.</p> <p>By incorporating this caching decorator into your code, you can optimize the execution of functions that involve complex computations, database queries, API calls, or any other operations that could benefit from caching.</p> <p>Overall, this library simplifies the implementation of caching in your applications, allowing you to enhance performance and reduce resource consumption effectively.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install and update using pip: <pre><code>pip install cachetoolz\n</code></pre></p>"},{"location":"#a-example","title":"A Example","text":"todo.py<pre><code>from dataclasses import asdict, dataclass, field\nfrom datetime import timedelta\nfrom uuid import UUID, uuid4\n\nfrom cachetoolz import cache\nfrom cachetoolz.coder import coder\n\nTODOS: list['Todo'] = []\n\n@dataclass\nclass Todo:\n    title: str\n    status: bool = field(default=False, compare=False)\n    id: UUID = field(default_factory=uuid4, compare=False)\n\n# Registering an object coder\n@coder.register\nclass TodoSerializer:\n    def encode(self, value: Todo):  # Need type annotated\n        return asdict(value)\n\n    def decode(self, value):\n        return Todo(**value)\n\n# Adding cache to function with expiry time in seconds\n@cache(ttl=120, namespace='todo')\ndef get_one(id: UUID):\n    return next(filter(lambda todo: todo.id == id, TODOS), None)\n\n# Adding expiry time using timedelta\n@cache(ttl=timedelta(minutes=30), namespace='todo')\ndef get_all():\n    return TODOS\n\n# Clear all caches on given namesoaces\n@cache.clear(namespaces=['todo'])\ndef add_one(title, status=False):\n    if (todo := Todo(title=title, status=status)) not in TODOS:\n        TODOS.append(todo)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#032---2023-12-28","title":"0.3.2 - 2023-12-28","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Python 3.12 support</li> </ul>"},{"location":"changelog/#031---2023-07-26","title":"0.3.1 - 2023-07-26","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Documentation</li> <li>Dependabot</li> <li>Pre-commit with gitlint</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Cache TTL (Time to Live) with timedelta</li> <li>Simple decorator <code>@cache</code> and <code>@cache.clear</code> receive the explicitly positional function</li> </ul>"},{"location":"changelog/#030---2023-07-20","title":"0.3.0 - 2023-07-20","text":""},{"location":"changelog/#feature","title":"Feature","text":"<ul> <li>Adds kwargs to receive and pass arguments to remote backend clients (redis and mongo)</li> </ul>"},{"location":"changelog/#020---2023-07-18","title":"0.2.0 - 2023-07-18","text":""},{"location":"changelog/#feature_1","title":"Feature","text":"<ul> <li>Bare decorator <code>@cache</code> and <code>@cache.clear</code></li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Decorator argument name cache from <code>expire</code> to <code>ttl</code></li> <li>The cache decorator only takes keyword arguments</li> </ul>"},{"location":"contributing/","title":"Contributor Guide","text":"<p>Thank you for your interest in improving this project. This project is open-source under the MIT license and welcomes contributions in the form of bug reports, feature requests, and pull requests.</p> <p>Here is a list of important resources for contributors:</p> <ul> <li>Source Code</li> <li>Documentation</li> <li>Issue Tracker</li> <li>Code of Conduct</li> </ul>"},{"location":"contributing/#how-to-report-a-bug","title":"How to report a bug","text":"<p>Report bugs on the Issue Tracker.</p> <p>When filing an issue, make sure to answer these questions:</p> <ul> <li>Which operating system and Python version are you using?</li> <li>Which version of this project are you using?</li> <li>What did you do?</li> <li>What did you expect to see?</li> <li>What did you see instead?</li> </ul> <p>The best way to get your bug fixed is to provide a test case, and/or steps to reproduce the issue.</p>"},{"location":"contributing/#how-to-set-up-your-development-environment","title":"How to set up your development environment","text":"<p>You need Python 3.8+, Poetry and optionally GNU Make.</p> <p>Install the package with development requirements:</p> With MakeWithout Make <pre><code>make install\n</code></pre> <pre><code>poetry install --with dev --with test --with ci --with docs -E redis -E mongo\npoetry run pre-commit install\npoetry run gitlint install-hook\n</code></pre> <p>You can now run an interactive Python session, or Nox with nox-poetry: <pre><code>poetry run python\npoetry run nox\n</code></pre></p>"},{"location":"contributing/#how-to-test-the-project","title":"How to test the project","text":"<p>Run the full test suite:</p> With MakeWithout Make <pre><code>NOXSESSION=tests make nox\n</code></pre> <pre><code>poetry run nox -s tests\n</code></pre> <p>List the available Nox sessions: <pre><code>poetry run nox --list-sessions\n</code></pre></p> <p>You can also run a specific Nox session. For example, invoke the unit test suite like this:</p> With MakeWithout Make <pre><code>NOXSESSION=fmt make nox\n</code></pre> <pre><code>poetry run nox -s fmt\n</code></pre> <p>Unit tests are located in the tests directory, and are written using the ward testing framework.</p>"},{"location":"contributing/#how-to-submit-changes","title":"How to submit changes","text":"<p>Open a pull request to submit changes to this project.</p> <p>Your pull request needs to meet the following guidelines for acceptance:</p> <ul> <li>The Nox test suite must pass without errors and warnings.</li> <li>Include unit tests. This project maintains code coverage.</li> <li>If your changes add functionality, update the documentation accordingly.</li> </ul> <p>Feel free to submit early, though\u2014we can always iterate on this.</p>"},{"location":"installation/","title":"Installation","text":"<p>cachetoolz is available from PyPI and can be installed by running</p> <pre><code>pip install cachetoolz\n</code></pre>"},{"location":"installation/#bundles","title":"Bundles","text":"<p>Cachetoolz also defines a group of bundles that can be used to install cachetoolz and the dependencies for a given feature.</p> <p>You can specify these in your requirements or on the pip command-line by using brackets. Multiple bundles can be specified by separating them by commas. <pre><code>pip install cachetoolz[redis]\npip install cachetoolz[redis,mongo]\n</code></pre></p> <p>The following bundles are available:</p>"},{"location":"installation/#backends","title":"Backends","text":"<ul> <li><code>cachetoolz[redis]</code>: for using Redis as a backend.</li> <li><code>cachetoolz[mongo]</code>: for using Mongo as a backend.</li> </ul>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#cachetoolz.decorator.Cache","title":"<code>cachetoolz.decorator.Cache</code>","text":"<p>Caches a function call and stores it in the namespace.</p> <p>Bare decorator, <code>@cache</code>, is supported as well as a call with keyword arguments <code>@cache(ttl=7200)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Union[AsyncBackendABC, BackendABC]</code> <p>Cache backend</p> required <p>Examples:</p> <p>With redis async backend</p> <pre><code>&gt;&gt;&gt; from cachetoolz import AsyncRedisBackend, Cache\n&gt;&gt;&gt; cache = Cache(AsyncRedisBackend())\n</code></pre> <p>With redis sync backend</p> <pre><code>&gt;&gt;&gt; from cachetoolz import RedisBackend, Cache\n&gt;&gt;&gt; cache = Cache(RedisBackend())\n</code></pre>"},{"location":"reference/#cachetoolz.decorator.Cache--cache","title":"@cache","text":"<p>Decorator for caching a function call.</p> <p>Parameters:</p> Name Type Description Default <code>ttl</code> <code>int | float | timedelta</code> <p>cache ttl (time to live)</p> <code>math.inf</code> <code>namespace</code> <code>str</code> <p>namespace to cache</p> <code>'default'</code> <code>typed</code> <code>bool</code> <p>If typed is set to true, function arguments of different types will be cached separately</p> <code>False</code> <code>keygen</code> <code>Optional[KeyGenerator]</code> <p>function to generate a cache identifier key</p> <code>None</code> <p>Examples:</p> <p>A simple cache</p> <pre><code>&gt;&gt;&gt; @cache\n... def func(*args, **kwargs):\n...     ...\n...\n</code></pre> <p>Specific a namespace</p> <pre><code>&gt;&gt;&gt; @cache(namespace='bar')\n... def func(*args, **kwargs):\n...     ...\n...\n</code></pre> <p>Set an expiration time in seconds</p> <pre><code>&gt;&gt;&gt; @cache(ttl=60)\n... def func(*args, **kwargs):\n...     ...\n...\n</code></pre> <p>Use timedelta to set the expiration</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; @cache(ttl=timedelta(days=1))\n... def func(*args, **kwargs):\n...     ...\n...\n</code></pre> <p>Differentiate caching based on argument types</p> <pre><code>&gt;&gt;&gt; @cache(typed=True)\n... def func(*args, **kwargs):\n...     ...\n...\n</code></pre> <p>Using a custom keygen</p> <pre><code>&gt;&gt;&gt; def custom_keygen(\n...     typed: bool, func: Func, *args: P.args, **kwargs: P.kwargs\n... ) -&gt; str:\n...     '''Build a key to a function.\n...\n...     Parameters\n...     ----------\n...     typed\n...         If typed is set to true, function arguments of different types\n...         will be cached separately\n...     func\n...         Function\n...     args\n...         Function positional arguments\n...     kwargs\n...         Named function arguments\n...\n...     Returns\n...     -------\n...         Cache identifier key\n...\n...     '''\n...\n&gt;&gt;&gt; @cache(keygen=custom_keygen)\n... def func(*args, **kwargs):\n...     ...\n...\n</code></pre>"},{"location":"reference/#cachetoolz.decorator.Cache.clear","title":"<code>clear</code>","text":"<p>Clears all caches for all namespaces.</p> <p>This decorator will clear all caches contained in the specified namespaces once the decorated function is executed</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>Sequence[str]</code> <p>namespace to be cleaned.</p> <code>('default',)</code> <p>Examples:</p> <p>A simple clear cache</p> <pre><code>&gt;&gt;&gt; @cache.clear\n... def func(*args, **kwargs):\n...     ...\n</code></pre> <p>Defining the namespaces to be cleaned up</p> <pre><code>&gt;&gt;&gt; @cache.clear(namespaces=['foo'])\n... def func(*args, **kwargs):\n...     ...\n</code></pre>"},{"location":"reference/#cachetoolz.backend","title":"<code>cachetoolz.backend</code>","text":"<p>Module interface.</p>"},{"location":"reference/#cachetoolz.backend.AsyncInMemory","title":"<code>AsyncInMemory</code>","text":"<p>             Bases: <code>AsyncBackendABC</code></p> <p>Async in memory backend.</p> <p>This backend is used to store caches in memory asynchronous.</p>"},{"location":"reference/#cachetoolz.backend.AsyncInMemory.clear","title":"<code>clear(namespace)</code>  <code>async</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.backend.AsyncInMemory.get","title":"<code>get(key)</code>  <code>async</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.backend.AsyncInMemory.set","title":"<code>set(key, value, expires_at)</code>  <code>async</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.backend.AsyncMongoBackend","title":"<code>AsyncMongoBackend</code>","text":"<p>             Bases: <code>AsyncBackendABC</code></p> <p>Async MongoDB cache.</p> <p>This backend is used to store caches mongo asynchronous.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>MongoDB URI.</p> <code>'localhost'</code> <code>database</code> <code>str</code> <p>Cache database name.</p> <code>'.cachetoolz'</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Takes the same constructor arguments as <code>pymongo.mongo_client.MongoClient</code>.</p> <code>{}</code>"},{"location":"reference/#cachetoolz.backend.AsyncMongoBackend.clear","title":"<code>clear(namespace)</code>  <code>async</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.backend.AsyncMongoBackend.get","title":"<code>get(key)</code>  <code>async</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.backend.AsyncMongoBackend.set","title":"<code>set(key, value, expires_at)</code>  <code>async</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.backend.AsyncRedisBackend","title":"<code>AsyncRedisBackend</code>","text":"<p>             Bases: <code>AsyncBackendABC</code></p> <p>Async Redis backend.</p> <p>This backend is used to store caches redis asynchronous.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Redis url.</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Takes the same constructor arguments as <code>redis.asyncio. client.Redis.from_url</code>. The <code>decode_responses</code> parameter will always be True as the result needs to be returned as a string.</p> <code>{}</code>"},{"location":"reference/#cachetoolz.backend.AsyncRedisBackend.clear","title":"<code>clear(namespace)</code>  <code>async</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.backend.AsyncRedisBackend.get","title":"<code>get(key)</code>  <code>async</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.backend.AsyncRedisBackend.set","title":"<code>set(key, value, expires_at)</code>  <code>async</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.backend.InMemory","title":"<code>InMemory</code>","text":"<p>             Bases: <code>BackendABC</code></p> <p>In memory backend.</p> <p>This backend is used to store caches in memory synchronous.</p>"},{"location":"reference/#cachetoolz.backend.InMemory.clear","title":"<code>clear(namespace)</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.backend.InMemory.get","title":"<code>get(key)</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.backend.InMemory.set","title":"<code>set(key, value, expires_at)</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.backend.MongoBackend","title":"<code>MongoBackend</code>","text":"<p>             Bases: <code>BackendABC</code></p> <p>MongoDB cache.</p> <p>This backend is used to store caches mongo synchronous.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>MongoDB URI.</p> <code>'localhost'</code> <code>database</code> <code>str</code> <p>Cache database name.</p> <code>'.cachetoolz'</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Takes the same constructor arguments as <code>pymongo.mongo_client.MongoClient</code>.</p> <code>{}</code>"},{"location":"reference/#cachetoolz.backend.MongoBackend.clear","title":"<code>clear(namespace)</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.backend.MongoBackend.get","title":"<code>get(key)</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.backend.MongoBackend.set","title":"<code>set(key, value, expires_at)</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.backend.RedisBackend","title":"<code>RedisBackend</code>","text":"<p>             Bases: <code>BackendABC</code></p> <p>Redis cache.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Redis url.</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Takes the same constructor arguments as <code>redis.client.Redis.from_url</code>. The <code>decode_responses</code> parameter will always be True as the result needs to be returned as a string.</p> <code>{}</code>"},{"location":"reference/#cachetoolz.backend.RedisBackend.clear","title":"<code>clear(namespace)</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.backend.RedisBackend.get","title":"<code>get(key)</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.backend.RedisBackend.set","title":"<code>set(key, value, expires_at)</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.coder","title":"<code>cachetoolz.coder</code>","text":"<p>Module interface.</p>"},{"location":"reference/#cachetoolz.coder.Coder","title":"<code>Coder</code>","text":"<p>             Bases: <code>CoderABC</code></p> <p>Coder class.</p>"},{"location":"reference/#cachetoolz.coder.Coder.decode","title":"<code>decode(value)</code>","text":"<p>Decode value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to decode.</p> required <p>Returns:</p> Name Type Description <code>decoded</code> <code>Any</code> <p>Value decoded.</p>"},{"location":"reference/#cachetoolz.coder.Coder.encode","title":"<code>encode(value)</code>","text":"<p>Encode value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to encode.</p> required <p>Returns:</p> Name Type Description <code>encoded</code> <code>Any</code> <p>Value encoded.</p>"},{"location":"reference/#cachetoolz.coder.Coder.register","title":"<code>register(serializer)</code>  <code>staticmethod</code>","text":"<p>Register a JSON serializer class.</p> <p>You can register a class for decoding, it needs to have the <code>encode</code> and <code>decode</code> methods where the <code>encode</code> method must have a parameter called <code>value</code> and must have the type annotated. These methods can be <code>instance</code>, <code>@staticmethod</code>, or <code>@classmethod</code>. The decode function will receive the exact value that is returned by the encode function.</p> <p>Parameters:</p> Name Type Description Default <code>class_</code> <code>Union[Type[SerializerABC], SerializerABC]</code> <p>Serializer class.</p> required <p>Examples:</p> <p>Class methods</p> <pre><code>&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; @coder.register\n&gt;&gt;&gt; class DequeSerializer:\n...     @classmethod\n...     def encode(cls, value: deque):\n...         return {'iterable': list(value), 'maxlen': value.maxlen}\n...\n...     @classmethod\n...     def decode(cls, value):\n...         return deque(val['iterable'], val['maxlen'])\n...\n</code></pre> <p>Static methods</p> <pre><code>&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; @coder.register\n&gt;&gt;&gt; class DequeSerializer:\n...     @staticmethod\n...     def encode(value: deque):\n...         return {'iterable': list(value), 'maxlen': value.maxlen}\n...\n...     @staticmethod\n...     def decode(value):\n...         return deque(val['iterable'], val['maxlen'])\n...\n</code></pre> <p>Instace methods</p> <pre><code>&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; @coder.register\n&gt;&gt;&gt; class DequeSerializer:\n...     def encode(self, value: deque):\n...         return {'iterable': list(value), 'maxlen': value.maxlen}\n...\n...     def decode(self, value):\n...         return deque(val['iterable'], val['maxlen'])\n...\n</code></pre> <p>When registering a class, it will be instantiated. Therefore, if the class requires any initialization parameters, you can register an instance of it along with the necessary parameters.</p> <pre><code>&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; class DequeCoder:\n...     def __init__(self, foo):\n...         self.foo = foo\n...\n...      def encode(self, value: deque):\n...         return {'iterable': list(value), 'maxlen': value.maxlen}\n...\n...     def decode(self, value):\n...         return deque(val['iterable'], val['maxlen'])\n...\n&gt;&gt;&gt; coder.register(DequeCoder(foo='bar'))\n</code></pre>"},{"location":"reference/#cachetoolz.coder.encoder","title":"<code>cachetoolz.coder.encoder</code>","text":"<p>Encoder module.</p>"},{"location":"reference/#cachetoolz.coder.encoder.Encoder","title":"<code>Encoder</code>","text":"<p>             Bases: <code>JSONEncoder</code></p> <p>JSON encoder class.</p>"},{"location":"reference/#cachetoolz.coder.encoder.register","title":"<code>register(name)</code>","text":"<p>Register a encoder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Encoder name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; @register('deque')\n... def _(value: deque):\n...     return {'iterable': list(value), 'maxlen': value.maxlen}\n...\n</code></pre>"},{"location":"reference/#cachetoolz.coder.decoder","title":"<code>cachetoolz.coder.decoder</code>","text":"<p>Decoder module.</p>"},{"location":"reference/#cachetoolz.coder.decoder.Decoder","title":"<code>Decoder</code>","text":"<p>             Bases: <code>JSONDecoder</code></p> <p>JSON decoder class.</p>"},{"location":"reference/#cachetoolz.coder.decoder.register","title":"<code>register(name)</code>","text":"<p>Register a decoder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Decoder name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; @register('deque')\n... def _(val: dict[str, Any]):\n...     return deque(val['iterable'], val['maxlen'])\n...\n</code></pre>"},{"location":"reference/#cachetoolz.abc","title":"<code>cachetoolz.abc</code>","text":"<p>Abstract module interface.</p>"},{"location":"reference/#cachetoolz.abc.AsyncBackendABC","title":"<code>AsyncBackendABC</code>","text":"<p>             Bases: <code>BaseBackend</code>, <code>ABC</code></p> <p>Abstract async backend.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>Package logger.</p>"},{"location":"reference/#cachetoolz.abc.AsyncBackendABC.clear","title":"<code>clear(namespace)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.abc.AsyncBackendABC.get","title":"<code>get(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.abc.AsyncBackendABC.set","title":"<code>set(key, value, expires_at)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.abc.BackendABC","title":"<code>BackendABC</code>","text":"<p>             Bases: <code>BaseBackend</code>, <code>ABC</code></p> <p>Abstract backend.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>Package logger.</p>"},{"location":"reference/#cachetoolz.abc.BackendABC.clear","title":"<code>clear(namespace)</code>  <code>abstractmethod</code>","text":"<p>Clear a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespaces</code> <code>str</code> <p>namespace to cache.</p> required"},{"location":"reference/#cachetoolz.abc.BackendABC.get","title":"<code>get(key)</code>  <code>abstractmethod</code>","text":"<p>Get a value if not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache identifier key.</p> required <p>Returns:</p> Name Type Description <code>with_cache</code> <code>Any</code> <p>Value cached.</p> <code>without_cache</code> <code>None</code> <p>If not exists or expired.</p>"},{"location":"reference/#cachetoolz.abc.BackendABC.set","title":"<code>set(key, value, expires_at)</code>  <code>abstractmethod</code>","text":"<p>Set a value with expires time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>cache identifier key.</p> required <code>value</code> <code>str</code> <p>value to cache encoded.</p> required <code>expires_at</code> <code>timedelta</code> <p>expiry time.</p> required"},{"location":"reference/#cachetoolz.abc.CoderABC","title":"<code>CoderABC</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract coder.</p>"},{"location":"reference/#cachetoolz.abc.CoderABC.decode","title":"<code>decode(value)</code>  <code>abstractmethod</code>","text":"<p>Decode value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to decode.</p> required <p>Returns:</p> Name Type Description <code>decoded</code> <code>Any</code> <p>Value decoded.</p>"},{"location":"reference/#cachetoolz.abc.CoderABC.encode","title":"<code>encode(value)</code>  <code>abstractmethod</code>","text":"<p>Encode value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to encode.</p> required <p>Returns:</p> Name Type Description <code>encode</code> <code>Any</code> <p>Value encoded.</p>"},{"location":"reference/#cachetoolz.abc.SerializerABC","title":"<code>SerializerABC</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract coder.</p>"},{"location":"reference/#cachetoolz.abc.SerializerABC.decode","title":"<code>decode(value)</code>  <code>abstractmethod</code>","text":"<p>Decode value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to decode</p> required <p>Returns:</p> Name Type Description <code>decoded</code> <code>Any</code> <p>Value decoded</p>"},{"location":"reference/#cachetoolz.abc.SerializerABC.encode","title":"<code>encode(value)</code>  <code>abstractmethod</code>","text":"<p>Encode value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to encode</p> required <p>Returns:</p> Name Type Description <code>encoded</code> <code>Any</code> <p>Value encoded</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#cache","title":"Cache","text":"<p>A memory cache is available for both synchronous and asynchronous functions. However, it's crucial to highlight that the cache will be reset or cleared whenever the program is interrupted.</p> <pre><code>from cachetoolz import cache\n\n# It's equivalent to that\nfrom cachetoolz import AsyncInMemory, Cache\ncache = Cache(AsyncInMemory())\n\n@cache()\ndef sub(x, y):\n    return x - y\n\n@cache()\nasync def mul(x, y):\n    return x * y\n</code></pre> <p>Caches a function call and stores it in the namespace.</p> <p>Bare decorator, <code>@cache</code>, is supported as well as a call with keyword arguments <code>@cache(ttl=7200)</code>.</p> Parameter Type Description Default <code>backend</code> Union[AsyncBackendABC, BackendABC] Cache backend required <p>With redis async backend <pre><code>from cachetoolz import AsyncRedisBackend, Cache\ncache = Cache(AsyncRedisBackend())\n</code></pre></p> <p>With redis sync backend <pre><code>from cachetoolz import RedisBackend, Cache\ncache = Cache(RedisBackend())\n</code></pre></p> <p>For more details on backends see backends section.</p>"},{"location":"usage/#cache_1","title":"@cache","text":"Parameter Type Description Default <code>ttl</code> <code>int</code>, <code>float</code>, <code>timedelta</code> cache ttl (time to live) <code>math.inf</code> <code>namespace</code> <code>str</code> namespace to cache <code>\"default\"</code> <code>typed</code> <code>bool</code> If typed is set to true, function arguments of different types will be cached separately <code>False</code> <code>keygen</code> <code>cachetoolz.types.KeyGenerator</code> function to generate a cache identifier key <code>cachetoolz.utils.default_keygen</code> <p>Examples:</p> <p>A simple cache <pre><code>&gt;&gt;&gt; @cache\ndef func(*args, **kwargs):\n    ...\n</code></pre></p> <p>Specific a namespace <pre><code>@cache(namespace='bar')\ndef func(*args, **kwargs):\n    ...\n</code></pre></p> <p>Set an expiration time in seconds <pre><code>@cache(ttl=60)\ndef func(*args, **kwargs):\n    ...\n</code></pre></p> <p>Use timedelta to set the expiration <pre><code>from datetime import timedelta\n@cache(ttl=timedelta(days=1))\ndef func(*args, **kwargs):\n    ...\n</code></pre></p> <p>Differentiate caching based on argument types <pre><code>@cache(typed=True)\ndef func(*args, **kwargs):\n    ...\n</code></pre></p> <p>Using a custom keygen <pre><code>def custom_keygen(\n    typed: bool, func: Func, *args: P.args, **kwargs: P.kwargs\n) -&gt; str:\n    '''Build a key to a function.\n\n    Parameters\n    ----------\n    typed\n        If typed is set to true, function arguments of different types\n        will be cached separately\n    func\n        Function\n    args\n        Function positional arguments\n    kwargs\n        Named function arguments\n\n    Returns\n    -------\n        Cache identifier key\n\n     '''\n\n@cache(keygen=custom_keygen)\ndef func(*args, **kwargs):\n    ...\n</code></pre></p>"},{"location":"usage/#cacheclear","title":"@cache.clear","text":"<p>Clears all caches for all namespaces.</p> <p>This decorator will clear all caches contained in the specified namespaces once the decorated function is executed</p> Parameter Type Description Default <code>namespaces</code> <code>Sequence[str]</code> namespace to be cleaned. <code>('default',)</code> <p>Examples:</p> <p>A simple clear cache <pre><code>@cache.clear\ndef func(*args, **kwargs):\n    ...\n</code></pre></p> <p>Defining the namespaces to be cleaned up <pre><code>@cache.clear(namespaces=['foo'])\ndef func(*args, **kwargs):\n    ...\n</code></pre></p>"},{"location":"usage/#backend","title":"Backend","text":""},{"location":"usage/#in-memory","title":"In Memory","text":"<p>Both synchronous and asynchronous in-memory backends are available. Just instantiate them, they don't take any arguments.</p> <p><pre><code>from cachetoolz import AsyncInMemory, InMemory\n\nasync_in_memory = AsyncInMemory()\nsync_in_memory = InMemory()\n</code></pre> Async functions can be decorated when the synchronous backend is being used, but it is important to be careful as there can be potential errors or inconsistencies when trying to access the backend</p>"},{"location":"usage/#redis","title":"Redis","text":"<p>With Redis, you have the flexibility to choose between using either the asynchronous or synchronous backend by simply specifying the connection string.</p>"},{"location":"usage/#redisbackend","title":"RedisBackend","text":"Parameter Type Description Default <code>url</code> <code>str</code> Redis url. required <code>kwargs</code> <code>dict[str, Any]</code> Takes the same constructor arguments as <code>redis.client.Redis.from_url</code>. The <code>decode_responses</code> parameter will always be <code>True</code> as the result needs to be returned as a string. <code>{}</code>"},{"location":"usage/#asyncredisbackend","title":"AsyncRedisBackend","text":"Parameter Type Description Default <code>url</code> <code>str</code> Redis url. required <code>kwargs</code> <code>dict[str, Any]</code> Takes the same constructor arguments as <code>redis.asyncio.client.Redis.from_url</code>. The <code>decode_responses</code> parameter will always be <code>True</code> as the result needs to be returned as a string. <code>{}</code>"},{"location":"usage/#mongo","title":"Mongo","text":"<p>Mongo also supports asynchronous and synchronous backend</p>"},{"location":"usage/#mongobackend","title":"MongoBackend","text":"Parameter Type Description Default <code>host</code> <code>str</code> MongoDB URI. <code>'localhost'</code> <code>database</code> <code>str</code> Cache database name. <code>'.cachetoolz'</code> <code>kwargs</code> <code>dict[str, Any]</code> Takes the same constructor arguments as <code>pymongo.mongo_client.MongoClient</code>. <code>{}</code>"},{"location":"usage/#asyncmongobackend","title":"AsyncMongoBackend","text":"Parameter Type Description Default <code>host</code> <code>str</code> MongoDB URI. <code>'localhost'</code> <code>database</code> <code>str</code> Cache database name. <code>'.cachetoolz'</code> <code>kwargs</code> <code>dict[str, Any]</code> Takes the same constructor arguments as <code>pymongo.mongo_client.MongoClient</code>. <code>{}</code>"},{"location":"usage/#coder","title":"Coder","text":"<p>The coder object is responsible for encoding and decoding python objects to json to be cached. Some classes are already supported but if you need you can add new encoders and decoders</p>"},{"location":"usage/#supported-types","title":"Supported Types","text":"<ul> <li>None</li> <li>bytes</li> <li>str</li> <li>int</li> <li>float</li> <li>bool</li> <li>dict</li> <li>set</li> <li>frozenset</li> <li>list</li> <li>tuple  # is decoded to a list</li> <li>uuid.UUID</li> <li>pathlib.Path</li> <li>collections.deque</li> <li>re.Pattern</li> <li>datetime.time</li> <li>datetime.date</li> <li>datetime.datetime</li> <li>datetime.timedelta</li> <li>decimal.Decimal</li> <li>ipaddress.IPv4Address</li> <li>apaddress.IPv4Interface</li> <li>apaddress.IPv4Network</li> <li>apaddress.IPv6Address</li> <li>apaddress.IPv6Interface</li> <li>apaddress.IPv6Network</li> </ul>"},{"location":"usage/#register-coder","title":"Register Coder","text":"<p>You can register a class for decoding, it needs to have the <code>encode</code> and <code>decode</code> methods where the <code>encode</code> method must have a parameter called <code>value</code> and must have the type annotated. These methods can be <code>instance</code>, <code>@staticmethod</code>, or <code>@classmethod</code>. The decode function will receive the exact value that is returned by the encode function.</p> <p>Class methods <pre><code>from collections import deque\n\n@coder.register\nclass DequeCoder:\n    @classmethod\n    def encode(cls, value: deque):\n        return {'iterable': list(value), 'maxlen': value.maxlen}\n\n    @classmethod\n    def decode(cls, value):\n        return deque(val['iterable'], val['maxlen'])\n</code></pre></p> <p>Static methods <pre><code>from collections import deque\n\n@coder.register\nclass DequeCoder:\n    @staticmethod\n    def encode(value: deque):\n        return {'iterable': list(value), 'maxlen': value.maxlen}\n\n    @staticmethod\n    def decode(value):\n        return deque(val['iterable'], val['maxlen'])\n</code></pre></p> <p>Instace methods <pre><code>from collections import deque\n\n@coder.register\nclass DequeCoder:\n    def encode(self, value: deque):\n        return {'iterable': list(value), 'maxlen': value.maxlen}\n\n    def decode(self, value):\n         return deque(val['iterable'], val['maxlen'])\n</code></pre></p> <p>When registering a class, it will be instantiated. Therefore, if the class requires any initialization parameters, you can register an instance of it along with the necessary parameters.</p> <pre><code>from collections import deque\n\nclass DequeCoder:\n    def __init__(self, foo):\n        self.foo = foo\n\n     def encode(self, value: deque):\n        return {'iterable': list(value), 'maxlen': value.maxlen}\n\n    def decode(self, value):\n        return deque(val['iterable'], val['maxlen'])\n\ncoder.register(DequeCoder(foo='bar'))\n</code></pre>"},{"location":"usage/#register-encode","title":"Register Encode","text":"<p>If you have no need to decode the result or prefer to add it separately, you have the option to register a single encoder.</p> <pre><code>from collections import deque\n\nfrom cachetoolz.coder import encoder\n\n\n@encoder.register('deque')\ndef _(value: deque):\n    return {'iterable': list(value), 'maxlen': value.maxlen}\n</code></pre>"},{"location":"usage/#register-decode","title":"Register Decode","text":"<p>When registering a decoder, it is essential to ensure that the name matches the name of the encoder. Failure to do so will result in a lack of connection between them.</p> <pre><code>from collections import deque\n\nfrom cachetoolz.coder import decoder\n\n@decoder.register('deque')\ndef _(value):\n    return deque(value['iterable'], value['maxlen'])\n</code></pre>"}]}